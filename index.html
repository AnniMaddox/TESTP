<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Sariel 的 Q 彈重力球</title>
<style>
    body {
        margin: 0; padding: 0; width: 100vw; height: 100vh; overflow: hidden;
        background-color: #1a1a1a;
        font-family: "微軟正黑體", sans-serif;
        touch-action: none; /* 禁止瀏覽器預設捲動 */
    }

    /* 提示文字 */
    .hint {
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: rgba(255, 255, 255, 0.3);
        font-size: 16px; pointer-events: none;
        text-align: center; width: 80%;
    }

    /* 如果是 iOS 需要按鈕授權 */
    #btn-permission {
        position: absolute; bottom: 20px; left: 50%;
        transform: translateX(-50%);
        padding: 12px 24px;
        background: #ff4081; color: white;
        border: none; border-radius: 30px;
        font-size: 16px; cursor: pointer;
        display: none; /* 預設隱藏，JS 判斷顯示 */
        box-shadow: 0 4px 10px rgba(255, 64, 129, 0.4);
        z-index: 100;
    }

    canvas { display: block; }
</style>
</head>
<body>

    <div class="hint">晃動手機，把球球撞開！<br>(點擊螢幕也可以增加球球)</div>
    <button id="btn-permission">開啟重力感應</button>
    <canvas id="world"></canvas>

<script>
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');
    const btn = document.getElementById('btn-permission');

    let width, height;
    let balls = [];
    // 重力變數
    let gravityX = 0;
    let gravityY = 1; // 預設一點點向下，避免一開始不動

    // ─── 球球設定 ───
    const BALL_COUNT = 15;
    const BOUNCE = 0.9; // 彈力係數 (0.9 代表很彈)
    const FRICTION = 0.99; // 空氣阻力

    class Ball {
        constructor(x, y, r) {
            this.x = x;
            this.y = y;
            this.r = r; // 半徑
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10;
            // 隨機馬卡龍色
            const hue = Math.random() * 360;
            this.color = `hsla(${hue}, 80%, 70%, 1)`;
            this.glow = `hsla(${hue}, 80%, 60%, 0.6)`;
        }

        update() {
            // 1. 施加重力 (手機晃動的核心)
            // 手機的重力感應值通常在 -10 到 10 之間，我們把它放大一點當作力
            this.vx += gravityX * 0.5;
            this.vy += gravityY * 0.5;

            // 2. 施加阻力 (讓它慢慢停下來，不會永遠亂飛)
            this.vx *= FRICTION;
            this.vy *= FRICTION;

            // 3. 限制最大速度 (防止穿牆 Bug 的關鍵！)
            const maxSpeed = 25; 
            const speed = Math.sqrt(this.vx**2 + this.vy**2);
            if (speed > maxSpeed) {
                this.vx = (this.vx / speed) * maxSpeed;
                this.vy = (this.vy / speed) * maxSpeed;
            }

            // 4. 移動
            this.x += this.vx;
            this.y += this.vy;

            // 5. 邊界檢查 (碰到牆壁反彈)
            if (this.x + this.r > width) {
                this.x = width - this.r;
                this.vx *= -BOUNCE;
            } else if (this.x - this.r < 0) {
                this.x = this.r;
                this.vx *= -BOUNCE;
            }

            if (this.y + this.r > height) {
                this.y = height - this.r;
                this.vy *= -BOUNCE;
            } else if (this.y - this.r < 0) {
                this.y = this.r;
                this.vy *= -BOUNCE;
            }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            // 發光邊緣
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
            // 內光暈
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.glow;
            ctx.shadowBlur = 0; // 畫完記得關掉，不然效能會差
        }
    }

    // ─── 初始化與重設 ───
    function init() {
        resize();
        balls = [];
        for (let i = 0; i < BALL_COUNT; i++) {
            createBall();
        }
    }

    function createBall(x, y) {
        let r = Math.random() * 20 + 15; // 大小 15~35
        let startX = x || Math.random() * (width - 100) + 50;
        let startY = y || Math.random() * (height - 100) + 50;
        balls.push(new Ball(startX, startY, r));
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }

    // ─── 物理引擎核心：防沾黏碰撞處理 ───
    function checkCollisions() {
        for (let i = 0; i < balls.length; i++) {
            for (let j = i + 1; j < balls.length; j++) {
                let b1 = balls[i];
                let b2 = balls[j];

                let dx = b2.x - b1.x;
                let dy = b2.y - b1.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let minDist = b1.r + b2.r;

                if (dist < minDist) {
                    // 撞到了！

                    // 1. 【防沾黏修正】：這就是妳之前球球黏住的原因！
                    // 我們要強制把它們「推開」，讓它們不重疊
                    let angle = Math.atan2(dy, dx);
                    let overlap = minDist - dist;
                    let force = overlap / 2; // 一人退一半

                    // 強制移動位置 (Positional Correction)
                    let moveX = Math.cos(angle) * force;
                    let moveY = Math.sin(angle) * force;

                    b1.x -= moveX;
                    b1.y -= moveY;
                    b2.x += moveX;
                    b2.y += moveY;

                    // 2. 彈性碰撞物理 (交換動能)
                    let tx = Math.cos(angle);
                    let ty = Math.sin(angle);

                    // 投影速度
                    let v1 = b1.vx * tx + b1.vy * ty;
                    let v2 = b2.vx * tx + b2.vy * ty;

                    // 交換速度 (加上彈力係數)
                    let v1Final = ((b1.r - b2.r) * v1 + 2 * b2.r * v2) / (b1.r + b2.r);
                    let v2Final = ((b2.r - b1.r) * v2 + 2 * b1.r * v1) / (b1.r + b2.r);
                    
                    // 加上一點點額外的彈力，讓它們更活潑
                    v1Final *= BOUNCE;
                    v2Final *= BOUNCE;

                    // 更新速度向量
                    b1.vx += tx * (v1Final - v1);
                    b1.vy += ty * (v1Final - v1);
                    b2.vx += tx * (v2Final - v2);
                    b2.vy += ty * (v2Final - v2);
                }
            }
        }
    }

    function loop() {
        ctx.clearRect(0, 0, width, height);
        
        balls.forEach(b => b.update());
        checkCollisions(); // 處理碰撞
        balls.forEach(b => b.draw());

        requestAnimationFrame(loop);
    }

    // ─── 事件監聽 ───
    window.addEventListener('resize', resize);
    
    // 點擊增加球球
    window.addEventListener('click', (e) => {
        // 如果點到按鈕就不加球
        if(e.target === btn) return;
        createBall(e.clientX, e.clientY);
    });

    // 搖一搖偵測 (暴力解法：速度太快就全部炸開)
    let lastX = 0, lastY = 0, lastZ = 0;
    window.addEventListener('devicemotion', (e) => {
        let acc = e.accelerationIncludingGravity;
        if (!acc) return;
        
        // 重力感應更新
        // Android 和 iOS 方向有時候會相反，這裡做通用處理
        // 我們讓球球跟著手機「倒」的方向跑
        gravityX = (acc.x || 0) * -1; // 左右
        gravityY = (acc.y || 0);      // 上下

        // 偵測劇烈搖晃 (Shake) -> 重置球球位置
        let speed = Math.abs(acc.x + acc.y + (acc.z||0) - lastX - lastY - lastZ);
        if (speed > 50) { // 搖得很大力
            balls.forEach(b => {
                b.vx += (Math.random() - 0.5) * 50; // 給一個巨大的爆炸速度
                b.vy += (Math.random() - 0.5) * 50;
            });
        }
        lastX = acc.x || 0;
        lastY = acc.y || 0;
        lastZ = acc.z || 0;
    });

    // iOS 13+ 權限處理
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        btn.style.display = 'block';
        btn.addEventListener('click', () => {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response == 'granted') {
                        btn.style.display = 'none';
                    } else {
                        alert("請允許重力感應，球球才跑得動喔！");
                    }
                })
                .catch(console.error);
        });
    } else {
        // 非 iOS 13+ 或 Android，直接開始
        btn.style.display = 'none';
    }

    init();
    loop();

</script>
</body>
</html>
